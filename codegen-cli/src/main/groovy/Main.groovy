import groovy.json.JsonSlurper

import java.time.ZonedDateTime

class Main implements Runnable {

    URL inputSpec
    File outputDir
    String packageName

    static void main(String[] args) {
        new Main(inputSpec: new URL(args[0]), outputDir: new File(args[1]), packageName: 'no.maddin.api').run()
    }

    void run() {

        def swagger = new JsonSlurper().parse(inputSpec)
        if (swagger?.swagger != '2.0') {
            throw new IllegalArgumentException('Can only read swagger 2.0 files')
        }
        swagger.typeRegistry = [:]
        swagger.typeRegistry = [:]
        swagger.typeRegistry << [
                string: 'String',
                date: 'ZonedDateTime',
                'date-time': 'ZonedDataTime',
                '#/definitions/Any': 'Object',
                'boolean': 'Boolean'
        ]

        swagger.resolveType = {model, propDetails ->
            if (propDetails?.type) {
                if (propDetails.type == 'array') {
                    model.imports << 'java.util.List'
                    return "List<${swagger.resolveType(model, propDetails.items)}>"
                } else {
                    return swagger.typeRegistry[propDetails.type]
                }
            } else if (propDetails?.$ref) {
                def refType = swagger.typeRegistry[propDetails.$ref]
                if (!refType) {
                    refType = (propDetails.$ref =~ /#\/definitions\/(.+)/)[ 0 ][ 1 ]
                    swagger.typeRegistry[propDetails.$ref] = refType
                }
                return refType
            } else {
                return 'Object'
            }
        }
        writeModels(swagger)
        writeApis(swagger)
    }

    void writeApis(Map swagger) {
        swagger.api = [:]
        swagger.api.defaultClassName = toClassName(swagger.info.title)
        swagger.api.packageName = packageName
        swagger.api.classNames = [] as Set

        swagger.paths.each{path, detail ->
            def pathSegments = path.split('/')
            if (pathSegments.length < 2) {
                detail.className = swagger.api.defaultClassName
            } else {
                detail.className = toClassName(pathSegments[1])
            }
            swagger.api.classNames << detail.className
        }

        def packagePath = new File(outputDir, packageName.replace('.' as char, File.separatorChar))
        swagger.api.classNames.each {className ->

            swagger.api.filename = new File(packagePath,  className + '.java')
            swagger.api.package = packageName

            (swagger.api.filename as File).parentFile.mkdirs()
            swagger.api.filename.withPrintWriter { apiFile ->

                writeApiStart(apiFile, swagger, className)
                swagger.paths.findAll { path, detail ->
                    detail.className == className
                }.each { path, detail ->
                    writeApiPath(apiFile, swagger, path, detail)
                }
                writeApiEnd(apiFile, swagger)
            }
        }
    }

    void writeApiStart(PrintWriter apiFile, Map swagger, String className) {
        apiFile.println "package ${swagger.api.packageName};\n\n"
        apiFile.println("class ${className} {")
    }

    void writeApiPath(PrintWriter apiFile, Map swagger, String path, Map pathDetails) {
        apiFile.println("// ${path}")
    }

    void writeApiEnd(PrintWriter apiFile, Map swagger) {
        apiFile.println("}")
    }

    void writeModels(Map swagger) {
        writeModel(swagger) { name, model ->
            (model.filename as File).parentFile.mkdirs()
            model.filename.withPrintWriter { modelFile ->

                modelFile.println "/* Generated by no.maddin:openapi-codegen: ${ZonedDateTime.now()} */"
                modelFile.println "package ${model.package};\n"

                model?.imports?.each {
                    modelFile.println "import ${it};"
                }
                modelFile.println()

                if (model?.classType == 'class') {
                    modelFile.println("@lombok.Data\n@lombok.Builder")
                    modelFile.println "@ApiModel(description = \"${model?.description}\")"
                    modelFile.println "public class ${name} {"
                    model?.properties?.each { propName, propDetail ->
                        modelFile.println "    @ApiModelProperty(value = \"${propDetail.description}\")"
                        modelFile.println "    @JsonProperty(\"${propName}\")"
                        modelFile.println "    private ${propDetail?.propType} ${propDetail.propName};\n"
                    }
                } else if (model?.classType == 'enum') {
                    modelFile.println("/**\n * ${model?.description}\n */")
                    modelFile.println("public enum ${name} {")
                    modelFile.println(model?.enum?.join(', '))

                } else {
                    throw new IllegalArgumentException("Unknown class type ${model?.classType}")
                }
                modelFile.println "}"
            }
        }
    }

    def writeModel(Map swagger, Closure<Map> eachModel) {

        def modelPackageName = "${packageName}.model"
        def packagePath = new File(outputDir, modelPackageName.replace('.' as char, File.separatorChar))
        swagger.definitions.each { name, model ->

            model.package = modelPackageName
            model.description = model?.description?.replace('\n', '\\n')

            // should the model be skipped? e.g. if it doesn't have any properties

            model.imports = [
                    'io.swagger.annotations.ApiModel',
                    'io.swagger.annotations.ApiModelProperty',
                    'com.fasterxml.jackson.annotation.JsonProperty'
            ].toSet()

            if (model?.type == 'object') {
                model.classType = 'class'
                if (!model?.properties) {
                    model.skip = true
                } else {
                    // process properties
                    model?.properties?.each { propName, propDetails ->
                        propDetails.propType = swagger.resolveType(model, propDetails)

                        propDetails.propName = propName.replace('@', 'at')
                    }
                }
            } else if (model?.type == 'string' && model?.enum) {
                model.classType = 'enum'
                if (model.enum.isEmpty()) {
                    model.skip = true
                }

            } else {
                model.skip = true
            }

            if (!model.skip) {
                // create File name for model
                model.filename = new File(packagePath, "${name}.java")
                eachModel(name, model)
            }
        }
    }

    String toClassName(String name) {
        name.replaceAll(/[^\p{Alnum}]/, '').trim().toLowerCase().capitalize() + 'Api'
    }
}
